Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 49
- reduce by rule: statement -> compoundStatement
- shift token (then go to state 81)
Conflict in grammar: multiple actions possible when lookahead token is SCOLON in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 59)
Conflict in grammar: multiple actions possible when lookahead token is LOOP in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 61)
Conflict in grammar: multiple actions possible when lookahead token is PRINT in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 62)
Conflict in grammar: multiple actions possible when lookahead token is VAR in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 53)
Conflict in grammar: multiple actions possible when lookahead token is IF in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 63)
Conflict in grammar: multiple actions possible when lookahead token is ID in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 68)
Conflict in grammar: multiple actions possible when lookahead token is NUMBER in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 69)
Conflict in grammar: multiple actions possible when lookahead token is DECIMAL in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 70)
Conflict in grammar: multiple actions possible when lookahead token is STRING in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 71)
Conflict in grammar: multiple actions possible when lookahead token is TRUE in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 72)
Conflict in grammar: multiple actions possible when lookahead token is FALSE in state 50
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 73)
Conflict in grammar: multiple actions possible when lookahead token is SCOLON in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 59)
Conflict in grammar: multiple actions possible when lookahead token is LOOP in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 61)
Conflict in grammar: multiple actions possible when lookahead token is PRINT in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 62)
Conflict in grammar: multiple actions possible when lookahead token is VAR in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 53)
Conflict in grammar: multiple actions possible when lookahead token is IF in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 63)
Conflict in grammar: multiple actions possible when lookahead token is ID in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 68)
Conflict in grammar: multiple actions possible when lookahead token is NUMBER in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 69)
Conflict in grammar: multiple actions possible when lookahead token is DECIMAL in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 70)
Conflict in grammar: multiple actions possible when lookahead token is STRING in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 71)
Conflict in grammar: multiple actions possible when lookahead token is TRUE in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 72)
Conflict in grammar: multiple actions possible when lookahead token is FALSE in state 51
- reduce by rule: compoundStatement -> localVarDeclaration
- shift token (then go to state 73)
Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 80
- reduce by rule: statement -> compoundStatement
- shift token (then go to state 122)
Conflict in grammar: multiple actions possible when lookahead token is FALSE in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is TRUE in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is STRING in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is DECIMAL in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is NUMBER in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is ID in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is IF in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is VAR in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is PRINT in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is LOOP in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is SCOLON in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 82
- reduce by rule: statementList -> statement
- reduce by rule: statementList -> statementList statement
Conflict in grammar: multiple actions possible when lookahead token is SCOLON in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 59)
Conflict in grammar: multiple actions possible when lookahead token is LOOP in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 61)
Conflict in grammar: multiple actions possible when lookahead token is PRINT in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 62)
Conflict in grammar: multiple actions possible when lookahead token is VAR in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 53)
Conflict in grammar: multiple actions possible when lookahead token is IF in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 63)
Conflict in grammar: multiple actions possible when lookahead token is ID in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 68)
Conflict in grammar: multiple actions possible when lookahead token is NUMBER in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 69)
Conflict in grammar: multiple actions possible when lookahead token is DECIMAL in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 70)
Conflict in grammar: multiple actions possible when lookahead token is STRING in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 71)
Conflict in grammar: multiple actions possible when lookahead token is TRUE in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 72)
Conflict in grammar: multiple actions possible when lookahead token is FALSE in state 84
- reduce by rule: compoundStatement -> localVarDeclaration statementList
- shift token (then go to state 73)
Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 84
- reduce by rule: compoundStatement -> statementList
- reduce by rule: compoundStatement -> localVarDeclaration statementList
Conflict in grammar: multiple actions possible when lookahead token is FALSE in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 73)
Conflict in grammar: multiple actions possible when lookahead token is TRUE in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 72)
Conflict in grammar: multiple actions possible when lookahead token is STRING in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 71)
Conflict in grammar: multiple actions possible when lookahead token is DECIMAL in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 70)
Conflict in grammar: multiple actions possible when lookahead token is NUMBER in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 69)
Conflict in grammar: multiple actions possible when lookahead token is ID in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 68)
Conflict in grammar: multiple actions possible when lookahead token is IF in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 63)
Conflict in grammar: multiple actions possible when lookahead token is VAR in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 53)
Conflict in grammar: multiple actions possible when lookahead token is PRINT in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 62)
Conflict in grammar: multiple actions possible when lookahead token is LOOP in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 61)
Conflict in grammar: multiple actions possible when lookahead token is SCOLON in state 84
- reduce by rule: compoundStatement -> statementList
- shift token (then go to state 59)
Conflict in grammar: multiple actions possible when lookahead token is VAR in state 170
- reduce by rule: localVarDeclaration -> VAR ID COLON type_specifier SCOLON
- shift token (then go to state 53)
Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 171
- reduce by rule: conditionalStatementAUX -> 
- reduce by rule: statementList -> statement
Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 185
- reduce by rule: conditionalStatementAUX -> 
- reduce by rule: statementList -> statement
Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 186
- reduce by rule: statementList -> statement
- shift token (then go to state 189)
Conflict in grammar: multiple actions possible when lookahead token is RBRACKET in state 187
- reduce by rule: statementList -> statement
- shift token (then go to state 190)

States with conflicts:
State 49
  mainFunction -> FUNCTION MAIN resolverMain ( ) COLON functionType_specifier LBRACKET compoundStatement .RBRACKET #lookaheads= $end EOF
  statement -> compoundStatement . #lookaheads= RBRACKET FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON
State 50
  compoundStatement -> statementList . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  statementList -> statementList .statement #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  statement -> .compoundStatement #lookaheads= FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON RBRACKET
  statement -> .initialConditionalStatement
  statement -> .expressionStatement
  statement -> .loopStatement
  statement -> .printStatement
  compoundStatement -> .statementList
  compoundStatement -> .localVarDeclaration
  compoundStatement -> .localVarDeclaration statementList
  initialConditionalStatement -> .conditionalStatement puntoSemanticoIF
  initialConditionalStatement -> .conditionalStatement ELSE puntoSemanticoElse LBRACKET statement conditionalStatementAUX RBRACKET
  expressionStatement -> .SCOLON
  expressionStatement -> .expression SCOLON
  loopStatement -> .LOOP loopPuntoSemantico ( expression ) loopExpresionPuntoSemantico LBRACKET statement RBRACKET loopExpresionPuntoSemanticoFinal
  printStatement -> .PRINT ( expression ) SCOLON
  statementList -> .statement #lookaheads= FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON RBRACKET
  statementList -> .statementList statement
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON localVarDeclaration
  conditionalStatement -> .IF ( expression ) puntoSemanticoIFEXP LBRACKET statement conditionalStatementAUX RBRACKET
  conditionalStatement -> .conditionalStatement ELIF puntoSemanticoIFEXP ( expression ) LBRACKET statement RBRACKET
  expression -> .assignmentExpression
  expression -> .expression COMA assignmentExpression
  assignmentExpression -> .conditionalExpression
  assignmentExpression -> .unaryExpression assignmentExpressionAssign assignmentExpression assignmentExpressionAux
  conditionalExpression -> .orExpression
  unaryExpression -> .ID
  unaryExpression -> .NUMBER
  unaryExpression -> .DECIMAL
  unaryExpression -> .STRING
  unaryExpression -> .TRUE
  unaryExpression -> .FALSE
  orExpression -> .andExpression
  orExpression -> .orExpression orExpressionOpPuntoSemantico andExpression orExpressionAux
  andExpression -> .equalExpression
  andExpression -> .andExpression andExpressionAND equalExpression andExpressionAux
  equalExpression -> .relationalExpression
  equalExpression -> .equalExpression equalExpressionEqual relationalExpression equalExpressionAux
  equalExpression -> .equalExpression equalExpressionNotEqual relationalExpression equalExpressionAux
  relationalExpression -> .arithmethicExpression
  relationalExpression -> .relationalExpression relationalExpressionAuxGreater arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxLess arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxGreaterEqual arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxLessEqual arithmethicExpression relationalExpressionAux
  arithmethicExpression -> .multiplicationExpression
  arithmethicExpression -> .arithmethicExpression aritmeticoSuma multiplicationExpression arithmethicPuntoSemantico
  arithmethicExpression -> .arithmethicExpression aritmeticoResta multiplicationExpression arithmethicPuntoSemantico
  multiplicationExpression -> .postfixExpression
  multiplicationExpression -> .multiplicationExpression multiplicacionMultiplo unaryExpression multiplicacionPuntoSemantico
  multiplicationExpression -> .multiplicationExpression multiplicacionDivision unaryExpression multiplicacionPuntoSemantico
  postfixExpression -> .unaryExpression
  postfixExpression -> .postfixExpression [ expression ]
  postfixExpression -> .postfixExpression ( )
  postfixExpression -> .postfixExpression ( argumentsList )
State 51
  compoundStatement -> localVarDeclaration . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  compoundStatement -> localVarDeclaration .statementList #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  statementList -> .statement
  statementList -> .statementList statement
  statement -> .compoundStatement
  statement -> .initialConditionalStatement
  statement -> .expressionStatement
  statement -> .loopStatement
  statement -> .printStatement
  compoundStatement -> .statementList #lookaheads= RBRACKET FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON
  compoundStatement -> .localVarDeclaration
  compoundStatement -> .localVarDeclaration statementList
  initialConditionalStatement -> .conditionalStatement puntoSemanticoIF
  initialConditionalStatement -> .conditionalStatement ELSE puntoSemanticoElse LBRACKET statement conditionalStatementAUX RBRACKET
  expressionStatement -> .SCOLON
  expressionStatement -> .expression SCOLON
  loopStatement -> .LOOP loopPuntoSemantico ( expression ) loopExpresionPuntoSemantico LBRACKET statement RBRACKET loopExpresionPuntoSemanticoFinal
  printStatement -> .PRINT ( expression ) SCOLON
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON localVarDeclaration
  conditionalStatement -> .IF ( expression ) puntoSemanticoIFEXP LBRACKET statement conditionalStatementAUX RBRACKET
  conditionalStatement -> .conditionalStatement ELIF puntoSemanticoIFEXP ( expression ) LBRACKET statement RBRACKET
  expression -> .assignmentExpression
  expression -> .expression COMA assignmentExpression
  assignmentExpression -> .conditionalExpression
  assignmentExpression -> .unaryExpression assignmentExpressionAssign assignmentExpression assignmentExpressionAux
  conditionalExpression -> .orExpression
  unaryExpression -> .ID
  unaryExpression -> .NUMBER
  unaryExpression -> .DECIMAL
  unaryExpression -> .STRING
  unaryExpression -> .TRUE
  unaryExpression -> .FALSE
  orExpression -> .andExpression
  orExpression -> .orExpression orExpressionOpPuntoSemantico andExpression orExpressionAux
  andExpression -> .equalExpression
  andExpression -> .andExpression andExpressionAND equalExpression andExpressionAux
  equalExpression -> .relationalExpression
  equalExpression -> .equalExpression equalExpressionEqual relationalExpression equalExpressionAux
  equalExpression -> .equalExpression equalExpressionNotEqual relationalExpression equalExpressionAux
  relationalExpression -> .arithmethicExpression
  relationalExpression -> .relationalExpression relationalExpressionAuxGreater arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxLess arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxGreaterEqual arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxLessEqual arithmethicExpression relationalExpressionAux
  arithmethicExpression -> .multiplicationExpression
  arithmethicExpression -> .arithmethicExpression aritmeticoSuma multiplicationExpression arithmethicPuntoSemantico
  arithmethicExpression -> .arithmethicExpression aritmeticoResta multiplicationExpression arithmethicPuntoSemantico
  multiplicationExpression -> .postfixExpression
  multiplicationExpression -> .multiplicationExpression multiplicacionMultiplo unaryExpression multiplicacionPuntoSemantico
  multiplicationExpression -> .multiplicationExpression multiplicacionDivision unaryExpression multiplicacionPuntoSemantico
  postfixExpression -> .unaryExpression
  postfixExpression -> .postfixExpression [ expression ]
  postfixExpression -> .postfixExpression ( )
  postfixExpression -> .postfixExpression ( argumentsList )
State 80
  functionDeclaration -> FUNCTION ID ( functionParameters ) COLON functionType_specifier LBRACKET compoundStatement .RBRACKET #lookaheads= FUNCTION
  statement -> compoundStatement . #lookaheads= RBRACKET FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON
State 82
  statementList -> statementList statement . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  statementList -> statement . #lookaheads= FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON RBRACKET
State 84
  compoundStatement -> localVarDeclaration statementList . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  statementList -> statementList .statement
  compoundStatement -> statementList . #lookaheads= RBRACKET FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON
  statement -> .compoundStatement
  statement -> .initialConditionalStatement
  statement -> .expressionStatement
  statement -> .loopStatement
  statement -> .printStatement
  compoundStatement -> .statementList
  compoundStatement -> .localVarDeclaration
  compoundStatement -> .localVarDeclaration statementList
  initialConditionalStatement -> .conditionalStatement puntoSemanticoIF
  initialConditionalStatement -> .conditionalStatement ELSE puntoSemanticoElse LBRACKET statement conditionalStatementAUX RBRACKET
  expressionStatement -> .SCOLON
  expressionStatement -> .expression SCOLON
  loopStatement -> .LOOP loopPuntoSemantico ( expression ) loopExpresionPuntoSemantico LBRACKET statement RBRACKET loopExpresionPuntoSemanticoFinal
  printStatement -> .PRINT ( expression ) SCOLON
  statementList -> .statement
  statementList -> .statementList statement
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON localVarDeclaration
  conditionalStatement -> .IF ( expression ) puntoSemanticoIFEXP LBRACKET statement conditionalStatementAUX RBRACKET
  conditionalStatement -> .conditionalStatement ELIF puntoSemanticoIFEXP ( expression ) LBRACKET statement RBRACKET
  expression -> .assignmentExpression
  expression -> .expression COMA assignmentExpression
  assignmentExpression -> .conditionalExpression
  assignmentExpression -> .unaryExpression assignmentExpressionAssign assignmentExpression assignmentExpressionAux
  conditionalExpression -> .orExpression
  unaryExpression -> .ID
  unaryExpression -> .NUMBER
  unaryExpression -> .DECIMAL
  unaryExpression -> .STRING
  unaryExpression -> .TRUE
  unaryExpression -> .FALSE
  orExpression -> .andExpression
  orExpression -> .orExpression orExpressionOpPuntoSemantico andExpression orExpressionAux
  andExpression -> .equalExpression
  andExpression -> .andExpression andExpressionAND equalExpression andExpressionAux
  equalExpression -> .relationalExpression
  equalExpression -> .equalExpression equalExpressionEqual relationalExpression equalExpressionAux
  equalExpression -> .equalExpression equalExpressionNotEqual relationalExpression equalExpressionAux
  relationalExpression -> .arithmethicExpression
  relationalExpression -> .relationalExpression relationalExpressionAuxGreater arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxLess arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxGreaterEqual arithmethicExpression relationalExpressionAux
  relationalExpression -> .relationalExpression relationalExpressionAuxLessEqual arithmethicExpression relationalExpressionAux
  arithmethicExpression -> .multiplicationExpression
  arithmethicExpression -> .arithmethicExpression aritmeticoSuma multiplicationExpression arithmethicPuntoSemantico
  arithmethicExpression -> .arithmethicExpression aritmeticoResta multiplicationExpression arithmethicPuntoSemantico
  multiplicationExpression -> .postfixExpression
  multiplicationExpression -> .multiplicationExpression multiplicacionMultiplo unaryExpression multiplicacionPuntoSemantico
  multiplicationExpression -> .multiplicationExpression multiplicacionDivision unaryExpression multiplicacionPuntoSemantico
  postfixExpression -> .unaryExpression
  postfixExpression -> .postfixExpression [ expression ]
  postfixExpression -> .postfixExpression ( )
  postfixExpression -> .postfixExpression ( argumentsList )
State 170
  localVarDeclaration -> VAR ID COLON type_specifier SCOLON . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  localVarDeclaration -> VAR ID COLON type_specifier SCOLON .localVarDeclaration #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON
  localVarDeclaration -> .VAR ID COLON type_specifier SCOLON localVarDeclaration
State 171
  initialConditionalStatement -> conditionalStatement ELSE puntoSemanticoElse LBRACKET statement .conditionalStatementAUX RBRACKET #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  statementList -> statement . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  conditionalStatementAUX -> . #lookaheads= RBRACKET
State 185
  conditionalStatement -> IF ( expression ) puntoSemanticoIFEXP LBRACKET statement .conditionalStatementAUX RBRACKET #lookaheads= RBRACKET ELSE ELIF FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON
  statementList -> statement . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  conditionalStatementAUX -> . #lookaheads= RBRACKET
State 186
  conditionalStatement -> conditionalStatement ELIF puntoSemanticoIFEXP ( expression ) LBRACKET statement .RBRACKET #lookaheads= RBRACKET ELSE ELIF FALSE TRUE STRING DECIMAL NUMBER ID IF VAR PRINT LOOP SCOLON
  statementList -> statement . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
State 187
  loopStatement -> LOOP loopPuntoSemantico ( expression ) loopExpresionPuntoSemantico LBRACKET statement .RBRACKET loopExpresionPuntoSemanticoFinal #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
  statementList -> statement . #lookaheads= RBRACKET SCOLON LOOP PRINT VAR IF ID NUMBER DECIMAL STRING TRUE FALSE
{ id: 'par', type: 'int' }
Expresion aritmetica
GENERANDO CUADRUPLOS
